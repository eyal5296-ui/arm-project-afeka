#include <Servo.h>
#include <cmath>
#define DEADZONE 5
Servo arm_z, arm_1r, arm_1l, arm_2, arm_3r, arm_3l, arm_end;

char msg[100]; // Buffer for received message
char feedback[150];
long int now;
int lx = 0, ly = 0;
int rx = 0, ry = 0;
int lt = 0, rt = 0;
int ab = 0, bb = 0, xb = 0, yb = 0, lb = 0, rb = 0;

int apress=0, ypress=0, bpress=0, xpress=0;

const float a1_scale = 0.000005;
const float az_scale = 0.000005;
const float a2_scale = 0.000005;
const float a3_scale = 0.00001;
const float e_scale = 0.01;

const double r_scale = 0.0000005;
const double z_scale = 0.0000005;

double az = 0;
double a1 = 0;
double a2 = 165;
double a3r = -180;
double a3l = -180;
double ae = 20;

double l1 = 0.22, l2 = 0.18, l4 = 0.2;
double r, rn, z, zn, ew, ep, er, cos_a2, num, den;

int state = 2; //0 is extended, 2 is home, 1,4 is up
int mode = 0;

/*  a1  = (-80, 80);
    a2  = (-50, 160);
    a3r = (0, 180);
    a3l = (-90, 90);
    az  = (0, 160);
*/

double a1rn, a1ln, a2n, a3rn, a3ln;

void ReadInput();
void StateSet();
void SetMode1();
void CalculateAngles();
void ApplyAngles();
double cos_deg(double degrees);
double sin_deg(double degrees);
double wrapTo180(double angle);

void setup() {
  Serial.begin(115200);
  arm_z.attach(3);
  arm_1r.attach(6);
  arm_1l.attach(5);
  arm_2.attach(9);
  arm_3r.attach(10);
  arm_3l.attach(11);
  arm_end.attach(13);

}

void loop() {
  
  ReadInput();

  StateSet();

  CalculateAngles();

  ApplyAngles();
  
}

void ReadInput()
{
  if (Serial.available()) 
  {
    int len = Serial.readBytesUntil('\0', msg, sizeof(msg) - 1);
    msg[len] = '\0'; // Null-terminate in case it's not

    // Parse the message
    sscanf(msg, "LS%d,%dRS%d,%dLT%dRT%dA%dB%dX%dY%dLB%dRB%d",
          &lx, &ly, &rx, &ry, &lt, &rt,
          &ab, &bb, &xb, &yb, &lb, &rb);
    sprintf(feedback, "q,r=%f,z=%f,ew=%f,a1=%f,a2=%f,ep=%f,er=%f,az=%f,ae=%f", r,z,ew,a1,a2,ep,er,az,ae);
    Serial.println(feedback);
  }
}

void StateSet()
{
  if (ab==1 && apress==0 && mode==0) //state input change
  {
    apress=1;
    state = 1;
    //state = state%4;
    now = millis();
  }

  if (ab==0)
  {
    apress=0;
  }

  if (bb==1 && bpress==0 && mode==0) //state input change
  {
    bpress=1;
    state = 0;
    //state = state%4;
    now = millis();
  }

  if (bb==0)
  {
    bpress=0;
  }

  if (xb==1 && xpress==0 && mode==0) //state input change
  {
    xpress=1;
    state = 2;
    //state = state%4;
    now = millis();
  }

  if (xb==0)
  {
    xpress=0;
  }

    if (yb==1 && ypress==0)
  {
    ypress=1;
    mode = !mode;
    Serial.print("mode ");
    Serial.println(mode);
    if (mode == 1) {SetMode1();}
  }

  if (yb==0) //mode change
    {
      ypress=0;
    }

    if (millis()-now<1000)
  {
    switch(state)
    {
      case 0:
        //az = 0;
        a1 = 0;
        a2 = 0;
        a3r = 0;
        a3l = 0;
        ae = 20;
      break;

      case 2:
      
       // az = 0;
        a1 = 0;
        a2 = 165;
        a3r = -180;
        a3l = -180;
        ae = 20;
      break;

      case 1:
      
        //az = 0;
        a1 = 0;
        a2 = 90;
        a3r = -90;
        a3l = -90;
        ae = 20;
      break;

      case 3:
      
        //az = 0;
        a1 = 0;
        a2 = 90;
        a3r = -90;
        a3l = -90;
        ae = 20;
      break;
    }
  }

}

void SetMode1() {
  // Placeholder for inverse kinematics logic
  Serial.println("SetMode1()");
  ep=(a3r+a3l)/2;
  er=(a3r-a3l)/2;
  ew=a1+a2+ep;
  r = l1*cos_deg(a1) + l2*cos_deg(a1+a2) + l4*cos_deg(ew);
  z = l1*sin_deg(a1) + l2*sin_deg(a1+a2) + l4*sin_deg(ew);
  /*Serial.print("r=");
  Serial.println(r);
  Serial.print("z=");
  Serial.println(z);
  Serial.print("ew=");
  Serial.println(ew);
  Serial.print("a1=");
  Serial.println(a1);
  Serial.print("a2=");
  Serial.println(a2);
  Serial.print("a3=");
  Serial.println((a3r+a3l)/2);*/

  rn = r-l4*cos_deg(ew);
  zn = z-l4*sin_deg(ew);
}

void CalculateAngles()
{
  if (mode == 0)
  {
    /*if (abs(lx) > DEADZONE) {
      az = map(lx, -255, 255, 135, 45);  // Update az based on lx
    }
    else {
      az = 90; // Stop if within deadzone
    }*/
    if (abs(lx) > DEADZONE) {
      az -= lx * az_scale;
    }
    if (az < 0) az = 0;
    if (az > 180) az = 180;

    if (abs(ly) > DEADZONE) {
      a1 -= ly * a1_scale;
    }

    if (abs(ry) > DEADZONE) {
      a2 -= ry * a2_scale;
    }
    if (abs(lt) > DEADZONE) {
      a3r += lt * a3_scale;
      a3l += lt * a3_scale;
    }
    if (abs(rt) > DEADZONE) {
      a3r -= rt * a3_scale;
      a3l -= rt * a3_scale;
    }
    if (abs(rx) > DEADZONE) {
      a3r -= rx * a3_scale;
      a3l += rx * a3_scale;
    }

    if (rb == 1) {
      ae -= rb*e_scale; 
    } 
    if (lb == 1) {
      ae += lb*e_scale; 
    } 
    if (ae < 0) ae = 0;
    if (ae > 150) ae = 150;
    ep=(a3r+a3l)/2;
    er=(a3r-a3l)/2;
    ew=a1+a2+ep;
    /*r = l1*cos_deg(a1) + l2*cos_deg(a1+a2) + l4*cos_deg(ew);
    z = l1*sin_deg(a1) + l2*sin_deg(a1+a2) + l4*sin_deg(ew);/**/
  }

  if (mode == 1)
  {
    /*if (abs(lx) > DEADZONE) {
      az = map(lx, -255, 255, 135, 45); 
    }
    else {
      az = 90; 
    }*/
    if (abs(lx) > DEADZONE) {
      az -= lx * az_scale*10;
    }
    if (az < 0) az = 0;
    if (az > 180) az = 180;

    if (abs(ly) > DEADZONE) {
      r += ly * r_scale;
    }
    if (abs(ry) > DEADZONE) {
      z += ry * z_scale;
    }
    if (abs(rt) > DEADZONE) {
      ew -= rt * a3_scale*15;
    }
    if (abs(lt) > DEADZONE) {
      ew += lt * a3_scale*15;
    }
    if (abs(rx) > DEADZONE) {
      er -= rx * a3_scale*10;
    }
    
    //open close gripper
    if (rb == 1) {
      ae -= rb*e_scale*10; 
    } 
    if (lb == 1) {
      ae += lb*e_scale*10; 
    } 
    if (ae < 0) ae = 0;
    if (ae > 150) ae = 150;
  

    ep = ew-a1-a2;
    a3r = ep+er;
    a3l = ep-er;
    
    
    rn = r-l4*cos_deg(ew);
    zn = z-l4*sin_deg(ew);

    //cos_q2 = (l1^2 + l2^2 - r_adjusted^2 - z_adjusted^2) / (2 * l1 * l2);
    cos_a2 = (l1*l1+l2*l2-rn*rn-zn*zn)/(2*l1*l2);
    if (cos_a2>1){cos_a2=1;}
    if (cos_a2<-1){cos_a2=-1;}

    //q2 = pi - acos(cos_q2);
    a2 = (M_PI-acos(cos_a2))*(180/M_PI);

    //numerator = l1 + l2 * cos(q2);
    //denominator = l2 * sin(q2);
    //q1 = atan2(z_adjusted, r_adjusted) - atan2(denominator, numerator);
    num = l1+l2*cos_deg(a2);
    den = l2*sin_deg(a2);
    //a1 = wrapTo180((atan2(zn, rn) - atan2(den, num)) * (180 / M_PI));
    a1 = (atan2(zn, rn) - atan2(den, num)) * (180 / M_PI);

    

  }
}

void ApplyAngles()
{
  a1rn = 90+a1;
  a1ln = 180-a1-10-90;
  a2n = 45 + a2*0.77;
  a3rn = -a3r;
  a3ln = a3l+180;

  arm_1r.write(a1rn);
  arm_1l.write(a1ln);
  arm_2.write(a2n);
  arm_3r.write(a3rn);
  arm_3l.write(a3ln);
  arm_z.write(az);
  arm_end.write(ae);
}
double cos_deg(double degrees) {
    return cos(degrees * M_PI / 180.0);
}
double sin_deg(double degrees) {
    return sin(degrees * M_PI / 180.0);
}

double wrapTo180(double angle) {
    while (angle > 180) angle -= 360;
    while (angle < -180) angle += 360;
    return angle;
}

